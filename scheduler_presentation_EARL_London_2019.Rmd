---
title: "Introducing {gs}"
subtitle: "A grammar of recurring calendar events"
author: "James Laird-Smith"
date: "2019/09/12"
output:
  xaringan::moon_reader:
    css: ["default.css", "default-fonts.css", "jls.css"]
    lib_dir: libs
    seal: false
    nature:
      titleSlideClass: [left, middle]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
class: left, top

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

# Introducing `{gs}`

### A grammar of recurring calendar events
.pull-left[
##### James Laird-Smith  
##### EARL Conference  
##### 12 September 2019
]

.bottom-left-img[

```{r echo=FALSE,  out.width="100%"}
knitr::include_graphics("EARL_logo_dark.png")
```

]
.pull-right[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

---
class: large, one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Why `{gs}`?

--

- R already has tools for dates and times.  

  - Eg. `base`, `lubridate` etc.
  - These can create evenly spaced events.
  
--

- R has few tools for schedules **when the event pattern is irregular**.
  
  - Eg. Summer Bank Holiday (last Monday in August)
  
--
  
- Schedules can get strangely complicated.

  - How would you program an event occuring on the last Monday OR Wednesday
    in August?
    
--

- Schedules can be important.

---
class: large, one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

.double-para-break[
# What is `{gs}`?
]

--

* **An R package** for recurring calendar events (schedules). 

--

* Functions for:  

  + Creating schedules.
  + Composing schedules.
  + Working with schedules.

--

* **A grammar:**

> A grammar is a framework that lays out the minimal set of independent 
components and a means of composing them to solve a wide range of problems
within a domain.  
> .pull-right[*- Hadley Wickham*<sup>1</sup>]

.my-footnote[<sup>1</sup> Wickham, H., 2015. Teaching Safe-Stats, Not Statistical 
Abstinence. online supplement discussion of “Mere Renovation is Too Little Too 
Late: We Need to Rethink Our Undergraduate Curriculum from the Ground Up” by 
G. Cobb, *The American Statistician*, 69.]

---
class: large, one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# A introductory example

```{r}
library(gs)
library(magrittr)
```

--

- How would you schedule New Year's Day?

--

- What is special about New Year's Day?

  - The first day of the year.
  
--

**`on_yday()`** is a dedicated function to make a schedule of events occurring on
certain days of the year.

```{r eval=FALSE, echo=TRUE}
on_yday(1)
```

---
class: large, one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Basic schedules

- Built on `lubridate` accessor functions:

--

```{r}
lubridate::yday(as.Date("2000-01-01"))
```

--

```{r eval=FALSE, echo=TRUE}
on_yday(1)
```

--

- Almost all are implemented:
  
```{r}
lubridate::wday(as.Date("2000-01-01"))
```

--

```{r eval=FALSE, echo=TRUE}
on_wday(7)
```

---
class: one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Using schedules

--

- Schedules can be made into objects:

```{r}
on_new_years_day <- on_yday(1)
```

--

- Once you have a schedule object, you can test whether certain dates fall
  on it. This is done using the **`happen()`** function.
  
--
  
```{r}
my_dates <- seq.Date(from = as.Date("2000-01-01"),
                     to = as.Date("2000-01-05"),
                     by = "1 day")

my_dates
```

--

```{r}
happen(on_new_years_day, my_dates)
```

---
class: one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Using schedules (cont.)

- Once we have a schedule object, we can get the events from it using the
  **`schedule_days()`** function.
  
--
  
```{r, error=TRUE}
schedule_days(on_new_years_day)
```

--

```{r}
schedule_days(on_new_years_day, 
              from = as.Date("2000-01-01"),
              to = as.Date("2004-12-31"))
```

--

```{r}
schedule_days(on_new_years_day, from = 2000, to = 2004)
```

---
class: one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Composing schedules

- Say you now wanted to create a schedule for Christmas day.

--

- What is special about Christmas day?

  - Use **`on_yday()`** again? Is it the 359th day of the year? Not always. Not
    in a leap year where it is the 360th.
    
  - It is always the 25th of December. 
  
--
  
```{r}
in_december <- in_month(12)     # All days in December!
on_twenty_fifth <- on_mday(25)  # The 25th day of every month!
```
  
--

- There is a function to find the intersection of two schedules called 
  **`only_occur()`**.
  
```{r}
on_christmas_day <- only_occur(in_month(12), on_mday(25))
```

--

```{r}
schedule_days(on_christmas_day, from = 2000, to = 2004)
```
  
---
class: one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Composing schedules (2)

--

- Say I wanted only Christmas days occuring on Sunday:

```{r}
on_christmas_day <- only_occur(in_month(12), on_mday(25))
```

--

```{r}
on_chrismas_sunday <- only_occur(on_christmas_day, on_wday(1))
```

--

- Getting the occurances this millennium.

```{r}
schedule_days(on_chrismas_sunday, from = 2000, to = 2019)
```

--

I could also use the pipe (**`%>%`**) operator to get the same result:

```{r}
on_chrismas_sunday <-
  on_mday(25) %>% 
  only_occur(in_month(12)) %>% 
  only_occur(on_wday(1))
```


--


---
class: one-quarter-spaced, one-half-para-break

.top-right-img[
```{r echo=FALSE, fig.pos="r", out.width="100%"}
knitr::include_graphics("gs_hex_sticker.png")
```
]

# Composing schedules (3)

- What if we wanted to do the reverse, which is to combine the events of two
  schedules.
  
  - For this there is the **`also_occur()`**

```{r}
on_public_holidays <- also_occur(on_christmas_day, on_new_years_day)
```

You can do the same as before

  


---

| `lubridate` | `gs` | 
|:------|:-----|
| `yday()`| `on_yday()`| 
| 123 | 123 | 
| 1 | 1 |


---

## Comparison with `{ggplot2}`
--

.pull-left[
### `{ggplot2}`
]
.pull-right[
### `{scheduler}`
]
--
.pull-left[
- .red[**Data visualisations**] can occur in almost limitless variety.
]
--
.pull-right[
- .red[**Schedules**] can occur in almost limitless variety.
]
--
.pull-left[
- Implements a .red[**grammar of graphics**]
]
--
.pull-right[
- Implements a .red[**grammar of schedules**]
]

---
# A boring regression

## A boring result:

```{r}
fit = lm(dist ~ 1 + speed, data = cars)
coef(summary(fit))
```

---
class: large
# Further work

- The {*vacationr*} package

- Wraps the most common country holidays.

---
class: large
# Practical applications

* Modelling with time series
 - Does the pattern change on holidays?
* Human resources
  - Calculating leave allowances
